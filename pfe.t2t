
= Packet Forwarding Engine (PFE) =[pfe]

Processor engines (PE):

|| PE ID | PE name ||
| 0 | CLASS0 |
| 1 | CLASS1 |
| 2 | CLASS2 |
| 3 | CLASS3 |
| 4 | CLASS4 |
| 5 | CLASS5 |
| 6 | TMU0 |
| 7 | TMU1 |
| 8 | TMU2 |
| 9 | TMU3 |
| 10 | UTIL |

The //Class// PEs are responsible for //class//ifying packets.

The TMU PEs are responsible for scheduling packets and shaping traffic.

The Util PE is responsible for all the other tasks.

== CBUS (common bus?) memory map ==[pfe_cbus]

The CBUS is shared by the ARM and all PEs.

|| Seen from | CBUS base address ||
| ARM | 0x9c000000 |
| Any PE | 0xc0000000 |

|| Base offset in CBUS | Size | Size (w/o mirrors) | Description ||
| 0x200000 | 0x10000 | ? | [EMAC1 #pfe_gemac] |
| 0x210000 | 0x10000 | ? | [EGPI1 #pfe_gpi] |
| 0x220000 | 0x10000 | ? | [EMAC2 #pfe_gemac] |
| 0x230000 | 0x10000 | ? | [EGPI2 #pfe_gpi] |
| 0x240000 | 0x10000 | 0x800 | [BMU1 #pfe_bmu] |
| 0x250000 | 0x10000 | 0x800 | [BMU2 #pfe_bmu] |
| 0x260000 | 0x10000 | ? | ARB |
| 0x270000 | 0x10000 | ? | DDR_CONFIG |
| 0x280000 | 0x10000 | ? | [HIF #pfe_hif] |
| 0x290000 | 0x10000 | ? | [HGPI #pfe_gpi] |
| 0x300000 | 0x10000 | ? | LMEM |
| 0x310000 | 0x10000 | ? | [TMU_CSR #pfe_tmu_csr] |
| 0x320000 | 0x10000 | ? | [CLASS_CSR #pfe_class_csr] |
| 0x330000 | 0x10000 | ? | [EMAC3 #pfe_gemac] |
| 0x340000 | 0x10000 | ? | [EGPI3 #pfe_gpi] |
| 0x350000 | 0x10000 | ? | HIF_NOCPY |
| 0x360000 | 0x10000 | ? | [UTIL_CSR #pfe_util_csr] |
| 0x370000 | 0x10000 | ? | CBUS_GPT |

Note: Do not attempt to perform a byte access at address 0xffff of a
peripheral as it will cause CBUS to hang. Instead, perform a 16-bit access at
address 0xfffe.

== Class PE memory map ==[pfe_class_memmap]

All addresses are given for the Class PE address space.

|| Region | Size (w/o mirrors) | Description ||
| 0x00000000-0x0000ffff | 0x2000 | DMEM (per PE data memory) |
| 0x00010000-0x0001ffff | 0x8000 | PMEM (per PE program memory)
| 0x00020000-0x85ffffff | ? | DDR + ACP + IRAM |
| 0xc0000000-0xc0ffffff | ? | CBUS |
| 0xc1000000-0xc1ffffff | ? | Class APB bus |
| 0xc2000000-0xc2ffffff | ? | Class AHB1 bus |
| 0xc3000000-0xc3ffffff | ? | Class AHB2 bus |

=== Class APB bus map ===[pfe_class_apb]

|| Region | Size (w/o mirrors) | Description ||
| 0xc1000000-0xc100ffff | ? | GPT (General Purpose Timer) |
| 0xc1010000-0xc101ffff | ? | UART |
| 0xc1020000-0xc102ffff | ? | PERG |
| 0xc1030000-0xc103ffff | ? | EFET |

=== Class AHB1 bus map ===[pfe_class_ahb1]

|| Region | Size (w/o mirrors) | Description ||
| 0xc2030000-0xc203ffff | ? | MAC hash |
| 0xc2050000-0xc205ffff | ? | VLAN hash |

=== Class AHB2 bus map ===[pfe_class_ahb2]

|| Region | Size (w/o mirrors) | Description ||
| 0xc3010000-0xc301ffff | 0x8000 | PE LMEM |
| 0xc3020000-0xc302ffff | ? | CCU |

== Gigabit Ethernet MAC (GEMAC) ==[pfe_gemac]

== GPI ==[pfe_gpi]

Generic Packet Interface?

=== GPI registers ===[pfe_gpi_regs]

|| GPI instance | Base offset in CBUS ||
| EGPI1 | 0x210000 |
| EGPI2 | 0x230000 |
| HGPI | 0x290000 |
| EGPI3 | 0x340000 |

|| Symbol | Offset | Description ||
| [GPI_VERSION #pfe_gpi_reg_gpi_version] | 0x000 | GPI silicon revision register |
| [GPI_CTRL #pfe_gpi_reg_gpi_ctrl] | 0x004 | GPI control register |
| [GPI_RX_CONFIG #pfe_gpi_reg_gpi_rx_config] | 0x008 | GPI Rx config register |
| [GPI_HDR_SIZE #pfe_gpi_reg_gpi_hdr_size] | 0x00c | GPI header size register |
| [GPI_BUF_SIZE #pfe_gpi_reg_gpi_buf_size] | 0x010 | GPI buffer size register |
| [GPI_LMEM_ALLOC_ADDR #pfe_gpi_reg_gpi_lmem_alloc_addr] | 0x014 | GPI LMEM alloc address register |
| [GPI_LMEM_FREE_ADDR #pfe_gpi_reg_gpi_lmem_free_addr] | 0x018 | GPI LMEM free address register |
| [GPI_DDR_ALLOC_ADDR #pfe_gpi_reg_gpi_ddr_alloc_addr] | 0x01c | GPI DDR alloc address register |
| [GPI_DDR_FREE_ADDR #pfe_gpi_reg_gpi_ddr_free_addr] | 0x020 | GPI DDR free address register |
| [GPI_CLASS_ADDR #pfe_gpi_reg_gpi_class_addr] | 0x024 | GPI CLASS address register |
| [GPI_DRX_FIFO #pfe_gpi_reg_gpi_drx_fifo] | 0x028 |  |
| [GPI_TRX_FIFO #pfe_gpi_reg_gpi_trx_fifo] | 0x02c |  |
| [GPI_INQ_PKTPTR #pfe_gpi_reg_gpi_inq_pktptr] | 0x030 | GPI packet input FIFO? |
| [GPI_DDR_DATA_OFFSET #pfe_gpi_reg_gpi_ddr_data_offset] | 0x034 | GPI data offset for DDR packets |
| [GPI_LMEM_DATA_OFFSET #pfe_gpi_reg_gpi_lmem_data_offset] | 0x038 | GPI data offset for LMEM packets |
| [GPI_TMLF_TX #pfe_gpi_reg_gpi_tmlf_tx] | 0x04c |  |
| [GPI_DTX_ASEQ #pfe_gpi_reg_gpi_dtx_aseq] | 0x050 |  |
| [GPI_FIFO_STATUS #pfe_gpi_reg_gpi_fifo_status] | 0x054 | GPI FIFO status register |
| [GPI_FIFO_DEBUG #pfe_gpi_reg_gpi_fifo_debug] | 0x058 | GPI FIFO debug register |
| [GPI_TX_PAUSE_TIME #pfe_gpi_reg_gpi_tx_pause_time] | 0x05c | GPI Tx pause time register |
| [GPI_LMEM_SEC_BUF_DATA_OFFSET #pfe_gpi_reg_gpi_lmem_sec_buf_data_offset] | 0x060 | ? |
| [GPI_DDR_SEC_BUF_DATA_OFFSET #pfe_gpi_reg_gpi_ddr_sec_buf_data_offset] | 0x064 | ? |
| [GPI_TOE_CHKSUM_EN #pfe_gpi_reg_gpi_toe_checksum_en] | 0x068 |  |
| [GPI_OVERRUN_DROPCNT #pfe_gpi_reg_gpi_overrun_dropcnt] | 0x06c | GPI dropped packets counter register |

==== GPI_VERSION (GPI_BASE + 0x000) ====[pfe_gpi_reg_gpi_version]

GPI silicon revision. 0x50 on my c2k chip.

|| Symbol | Bit range | R/W | Description ||
| VERSION | ?-0 | R | GPI silicon revision |

==== GPI_CTRL (GPI_BASE + 0x004) ====[pfe_gpi_reg_gpi_ctrl]

GPI control register. The ENABLE bit must be set prior attempting to access
the other GPI registers (except GPI_VERSION), otherwise the transaction may
hang forever (or until the watchdog kicks in).

Performing a software reset will not reset the value of the configuration
registers, only the internal state will be cleared.

|| Symbol | Bit range | R/W | Description ||
| SW_RESET | 1 | RW | Perform software reset. Self-clearing. |
| ENABLE | 0 | RW | BMU enable. 0=disable 1=enable |

==== GPI_RX_CONFIG (GPI_BASE + 0x008) ====[pfe_gpi_reg_gpi_rx_config]

Rx configuration register.

Depending on their size, the packets may be written to LMEM for small packets, or DDR for larger ones.

|| Symbol | Bit range | R/W | Description ||
| LMEM_RTRY_CNT | 31-16 | RW | LMEM write retry counter. Typical value is 0x40. |
| DDR_BUF_EN | 1 | RW | Enable use of buffers in DDR |
| LMEM_BUF_EN | 0 | RW | Enable use of buffers in LMEM |

==== GPI_HDR_SIZE (GPI_BASE + 0x00c) ====[pfe_gpi_reg_gpi_hdr_size]

Header size configuration register.

Depending on whether packets are written to DDR or LMEM, the size of the header
may differ. This register allows configuration of the header size for LMEM and
DDR buffers.

|| Symbol | Bit range | R/W | Description ||
| DDR_HDR_SIZE | 31-16 | RW | Header size for buffers in DDR. Typical value: 0x100 |
| LMEM_HDR_SIZE | 15-0 | RW | Header size for buffers in LMEM. Typical value: 0x10 |

==== GPI_BUF_SIZE (GPI_BASE + 0x010) ====[pfe_gpi_reg_gpi_buf_size]

Buffer size configuration register.

Depending on whether packets are written to DDR or LMEM, the size of the buffer
may differ. This register allows configuration of the buffer size for LMEM and
DDR buffers. The header size is included in the buffer size.

|| Symbol | Bit range | R/W | Description ||
| DDR_BUF_SIZE | 31-16 | RW | Size of DDR buffers. Typical value: 0x800 |
| LMEM_BUF_SIZE | 15-0 | RW | Size of LMEM buffers Typical value: 0x80 |

==== GPI_LMEM_ALLOC_ADDR (GPI_BASE + 0x014) ====[pfe_gpi_reg_gpi_lmem_alloc_addr]

Address in the PE address space of the
[BMU_ALLOC_CTRL #pfe_bmu_reg_bmu_alloc_ctrl] register of the [BMU #pfe_bmu]
instance to use to allocate a new buffer in LMEM. Each read operation to the
specified address must return the address of a newly-allocated buffer, or 0 if
no buffer is available.

The buffer size for the BMU must be greater or equal to the one configured in
the GPI.

|| Symbol | Bit range | R/W | Description ||
| LMEM_ALLOC_ADDR | 31-0 | RW | Address of the BMU buffer allocation register to use for LMEM buffer allocation. |

==== GPI_LMEM_FREE_ADDR (GPI_BASE + 0x018) ====[pfe_gpi_reg_gpi_lmem_free_addr]

Address in the PE address space of the
[BMU_FREE_CTRL #pfe_bmu_reg_bmu_free_ctrl] register of the [BMU #pfe_bmu]
instance to used to manage buffers in LMEM. The addresses of buffers to free
will be written at that address.

|| Symbol | Bit range | R/W | Description ||
| LMEM_FREE_ADDR | 31-0 | RW | Address of the BMU buffer allocation register to use for LMEM buffer allocation. |

==== GPI_DDR_ALLOC_ADDR (GPI_BASE + 0x01c) ====[pfe_gpi_reg_gpi_ddr_alloc_addr]

Address in the PE address space of the
[BMU_ALLOC_CTRL #pfe_bmu_reg_bmu_alloc_ctrl] register of the [BMU #pfe_bmu]
instance to use to allocate a new buffer in DDR. Each read operation to the
specified address must return the address of a newly-allocated buffer, or 0 if
no buffer is available.

The buffer size for the BMU must be greater or equal to the one configured in
the GPI.

|| Symbol | Bit range | R/W | Description ||
| DDR_ALLOC_ADDR | 31-0 | RW | Address of the BMU buffer allocation register to use for DDR buffer allocation. |

==== GPI_DDR_FREE_ADDR (GPI_BASE + 0x020) ====[pfe_gpi_reg_gpi_ddr_free_addr]

Address in the PE address space of the
[BMU_FREE_CTRL #pfe_bmu_reg_bmu_free_ctrl] register of the [BMU #pfe_bmu]
instance to used to manage buffers in DDR. The addresses of buffers to free
will be written at that address.

|| Symbol | Bit range | R/W | Description ||
| DDR_FREE_ADDR | 31-0 | RW | Address of the BMU buffer allocation register to use for DDR buffer allocation. |

==== GPI_CLASS_ADDR (GPI_BASE + 0x024) ====[pfe_gpi_reg_gpi_class_addr]

Address in the PE address space of the INQ_PKTPTR FIFO register in the
[CLASS_CSR block #pfe_class_csr].

|| Symbol | Bit range | R/W | Description ||
| CLASS_ADDR | 31-0 | RW | Address of CLASS FIFO. |

==== GPI_DRX_FIFO (GPI_BASE + 0x028) ====[pfe_gpi_reg_gpi_drx_fifo]

Data? Rx FIFO depth? register?

|| Symbol | Bit range | R/W | Description ||
| ? | 15-0 | RW | ? Default value: 0x80 |

==== GPI_TRX_FIFO (GPI_BASE + 0x02c) ====[pfe_gpi_reg_gpi_trx_fifo]

? Rx FIFO depth? register?

|| Symbol | Bit range | R/W | Description ||
| ? | 15-0 | RW | ? Default value: 0x80 |

==== GPI_INQ_PKTPTR (GPI_BASE + 0x030) ====[pfe_gpi_reg_gpi_inq_pktptr]

Tx packet descriptor address FIFO?

The address of the packet descriptor for the packet to send can be written into
this register?

|| Symbol | Bit range | R/W | Description ||
| PKTPTR | 31-0 | RW | Address of the Tx descriptor of the packet to send? |

==== GPI_DDR_DATA_OFFSET (GPI_BASE + 0x034) ====[pfe_gpi_reg_gpi_ddr_data_offset]

Offset in the DDR buffer where data starts.

|| Symbol | Bit range | R/W | Description ||
| DATA_OFFSET | 8-0 | RW | Offset in the DDR buffer to the start of data region. Typical value: 0x100 |

==== GPI_LMEM_DATA_OFFSET (GPI_BASE + 0x038) ====[pfe_gpi_reg_gpi_lmem_data_offset]

Offset in the LMEM buffer where data starts.

|| Symbol | Bit range | R/W | Description ||
| DATA_OFFSET | 7-0 | RW | Offset in the LMEM buffer to the start of data region. Typical value: 0x10 |

==== GPI_TMLF_TX (GPI_BASE + 0x04c) ====[pfe_gpi_reg_gpi_tmlf_tx]

Something to do with TMU?

|| Symbol | Bit range | R/W | Description ||
| TMLF_TXTHRES | 7-0 | RW | Something Tx threshold value. Typical value: 0xbc |

==== GPI_DTX_ASEQ (GPI_BASE + 0x050) ====[pfe_gpi_reg_gpi_dtx_aseq]

Unknown.

|| Symbol | Bit range | R/W | Description ||
| ASEQ_LEN | 7-0 | RW | Unknown. Typical value: 0x40. EGPI1 has value 0x50. |

==== GPI_FIFO_STATUS (GPI_BASE + 0x054) ====[pfe_gpi_reg_gpi_fifo_status]

Some FIFO status register. Format unknown.

|| Symbol | Bit range | R/W | Description ||
| STICK? | 0 | RW | Keep Tx on hold? |

==== GPI_FIFO_DEBUG (GPI_BASE + 0x058) ====[pfe_gpi_reg_gpi_fifo_debug]

Some FIFO debug register.

|| Symbol | Bit range | R/W | Description ||
| TX_PKTS | 27-23 | R | Tx bytes |
| RX_PKTS | 22-18 | R | Tx bytes |
| TX_BYTES | 17-9 | R | Tx bytes |
| RX_BYTES | 8-0 | R | Rx bytes |

==== GPI_TX_PAUSE_TIME (GPI_BASE + 0x05c) ====[pfe_gpi_reg_gpi_tx_pause_time]

Tx pause frame time?

|| Symbol | Bit range | R/W | Description ||
| TXPAUSE | 15-0 | RW | Tx pause time? Time unit unknown. Typical value: 0xffff |

==== GPI_LMEM_SEC_BUF_DATA_OFFSET (GPI_BASE + 0x060) ====[pfe_gpi_reg_gpi_lmem_sec_buf_data_offset]

Purpose unknown. Maybe offset to additional security context?

|| Symbol | Bit range | R/W | Description ||
| DATA_OFFSET | 15-0 | RW | Typical value: 0x0 |

==== GPI_DDR_SEC_BUF_DATA_OFFSET (GPI_BASE + 0x064) ====[pfe_gpi_reg_gpi_ddr_sec_buf_data_offset]

Purpose unknown. Maybe offset to additional security context?

|| Symbol | Bit range | R/W | Description ||
| DATA_OFFSET | 15-0 | RW | Typical value: 0x0 |

==== GPI_TOE_CHKSUM_EN (GPI_BASE + 0x068) ====[pfe_gpi_reg_gpi_toe_checksum_en]

Control some kind of checksum offloading?

|| Symbol | Bit range | R/W | Description ||
| TOE_CHKSUM_EN | 0 | RW | Enable checksum ??? |

==== GPI_OVERRUN_DROPCNT (GPI_BASE + 0x06c) ====[pfe_gpi_reg_gpi_overrun_dropcnt]

Counter of dropped packets.

|| Symbol | Bit range | R/W | Description ||
| DROPCNT | 31-0 | RW | Number of dropped packets. |


== Buffer Management Unit (BMU) ==[pfe_bmu]

The buffer management unit (BMU) manages a buffer pool, allowing multiple
peripherals to acquire and release buffers from the pool.

The base address of the buffer pool is configurable, as well as the buffer
size. The number of buffers in the pool is configurable too, to a limit of
65535 buffers.

The BMU does not perform any DMA transfers; the state of the buffer pool is
kept in an internal memory which can be cleared by a software reset.

The BMU can generate interrupt requests to notify a PE of buffer pool state
changes.

When a peripheral needs a buffer, it can allocate one by reading the
BMU_ALLOC_CTRL register. If a buffer is available, its address will be returned
and the BMU will mark this buffer as allocated. If no buffer is available, the
address 0 will be returned.

To free a previously allocated buffer, the peripheral must write the buffer
address into the BMU_FREE_CTRL register. If the peripheral attempts to double
free a buffer, the address of the offending free operation will be stored in
the BMU_FREE_ERR_ADDR register.

=== BMU registers ===[pfe_bmu_regs]

|| BMU instance | Base offset in CBUS ||
| BMU1 | 0x240000 |
| BMU2 | 0x250000 |

|| Symbol | Offset | Description ||
| [BMU_VERSION #pfe_bmu_reg_bmu_version] | 0x000 | BMU version register (reads 0x21 on my hardware) |
| [BMU_CTRL #pfe_bmu_reg_bmu_ctrl] | 0x004 | BMU control register (enable/reset) |
| [BMU_UCAST_CONFIG #pfe_bmu_reg_bmu_ucast_config] | 0x008 | Number of buffers in the pool |
| [BMU_UCAST_BASE_ADDR #pfe_bmu_reg_bmu_ucast_base_addr] | 0x00c | Base address to the buffer pool |
| [BMU_BUF_SIZE #pfe_bmu_reg_bmu_buf_size] | 0x010 | Size of one buffer in the pool |
| [BMU_BUF_CNT #pfe_bmu_reg_bmu_buf_cnt] | 0x014 | Not implemented? Always reads 0 and writes have no visible effect. |
| [BMU_THRES #pfe_bmu_reg_bmu_thres] | 0x018 | BMU buffer count threshold |
| [BMU_INT_SRC #pfe_bmu_reg_bmu_int_src] | 0x020 | BMU interrupt source register |
| [BMU_INT_ENABLE #pfe_bmu_reg_bmu_int_enable] | 0x024 | BMU interrupt enable register |
| [BMU_ALLOC_CTRL #pfe_bmu_reg_bmu_alloc_ctrl] | 0x030 | Allocates one buffer from the pool |
| [BMU_FREE_CTRL #pfe_bmu_reg_bmu_free_ctrl] | 0x034 | Free one previously allocated buffer from the pool |
| [BMU_FREE_ERR_ADDR #pfe_bmu_reg_bmu_free_err_addr] | 0x038 | Address of buffer used in invalid free operation |
| [BMU_CURR_BUF_CNT #pfe_bmu_reg_bmu_curr_buf_cnt] | 0x03c | Number of buffers currently allocated |
| [BMU_MCAST_CNT #pfe_bmu_reg_bmu_mcast_cnt] | 0x040 | Unknown |
| [BMU_MCAST_ALLOC_CTRL #pfe_bmu_reg_bmu_mcast_alloc_ctrl] | 0x044 | Unknown |
| [BMU_REM_BUF_CNT #pfe_bmu_reg_bmu_rem_buf_cnt] | 0x048 | Number of remaining free buffers in the pool |
| [BMU_LOW_WATERMARK #pfe_bmu_reg_bmu_low_watermark] | 0x050 | Low watermark value |
| [BMU_HIGH_WATERMARK #pfe_bmu_reg_bmu_high_watermark] | 0x054 | High watermark value |
| [BMU_INT_MEM_ACCESS #pfe_bmu_reg_bmu_int_mem_access] | 0x100 | Internal memory access register |

==== BMU_VERSION (BMU_BASE + 0x000) ====[pfe_bmu_reg_bmu_version]

BMU silicon revision. 0x21 on my c2k chip.

|| Symbol | Bit range | R/W | Description ||
| VERSION | ?-0 | R | BMU silicon revision |

==== BMU_CTRL (BMU_BASE + 0x004) ====[pfe_bmu_reg_bmu_ctrl]

BMU control register. The ENABLE bit must be set prior attempting to access
the other BMU registers (except BMU_VERSION), otherwise the transaction may
hang forever (or until the watchdog kicks in).

Performing a software reset will not reset the value of the configuration
registers, only the internal state will be cleared.

|| Symbol | Bit range | R/W | Description ||
| SW_RESET | 1 | RW | Perform software reset. Self-clearing. |
| ENABLE | 0 | RW | BMU enable. 0=disable 1=enable |

==== BMU_UCAST_CONFIG (BMU_BASE + 0x008) ====[pfe_bmu_reg_bmu_ucast_config]

Number of buffers in the pool.

|| Symbol | Bit range | R/W | Description ||
| BUF_COUNT | 15-0 | RW | Total number of buffers in the pool. |

==== BMU_UCAST_BASE_ADDR (BMU_BASE + 0x00c) ====[pfe_bmu_reg_bmu_ucast_base_addr]

Base address of the buffer pool.

The BASE_ADDRESS value is only used to convert between the buffer index, used
internally, and the full physical address, used for the BMU_ALLOC_CTRL and
BMU_FREE_CTRL registers.

|| Symbol | Bit range | R/W | Description ||
| BASE_ADDRESS | 31-0 | RW | Base address of the buffer pool. |

==== BMU_BUF_SIZE (BMU_BASE + 0x010) ====[pfe_bmu_reg_bmu_buf_size]

Size of one buffer in the pool.

The size in bytes is computed as follow:

```
BUF_SIZE_BYTES = 1 << BUF_SIZE
```

|| Symbol | Bit range | R/W | Description ||
| BUF_SIZE | 15-0 | RW | Buffer size in powers of 2 (the BUF_SIZE value from above formula). |

==== BMU_BUF_CNT (BMU_BASE + 0x014) ====[pfe_bmu_reg_bmu_buf_cnt]

Unknown. Always reads 0. Writes have no visible effect.

==== BMU_THRES (BMU_BASE + 0x18) ====[pfe_bmu_reg_bmu_thres]

Number of allocated buffer threshold at which an interrupt request should be
generated.

|| Symbol | Bit range | R/W | Description ||
| ? | 31-16 | RW | Purpose unknown. |
| THRES | 15-0 | RW | An interrupt request is generated as long as the number of allocated buffer is greater or equal than THRES. |

==== BMU_INT_SRC (BMU_BASE + 0x20) ====[pfe_bmu_reg_bmu_int_src]

Interrupt source pending and acknowledge register.

Reading from this register shows the pending interrupt requests.

Writing into this registers acknowledges the interrupt requests which have
their bit set in the value written.

|| Symbol | Bit range | R/W | Description ||
| ? | 8 | RW | ? |
| ? | 7 | RW | ? |
| ? | 6 | RW | ? |
| ? | 5 | RW | ? |
| INVALID_FREE | 4 | RW | Set when freeing an already free buffer, or freeing a buffer outside the pool. |
| THRES | 3 | RW | Set when the number of allocated buffers is greater or equal to the THRES value set in the BMU_THRES register. |
| FULL | 2 | RW | Set when all buffers are allocated. |
| EMPTY | 1 | RW | Set when no buffer is allocated. |
| ? | 0 | RW | ? |

==== BMU_INT_ENABLE (BMU_BASE + 0x24) ====[pfe_bmu_reg_bmu_int_enable]

Interrupt source enable register.

|| Symbol | Bit range | R/W | Description ||
| ? | 8 | RW | ? |
| ? | 7 | RW | ? |
| ? | 6 | RW | ? |
| ? | 5 | RW | ? |
| INVALID_FREE | 4 | RW | See description in BMU_INT_SRC. 0=disable 1=enable |
| THRES | 3 | RW | See description in BMU_INT_SRC. 0=disable 1=enable |
| FULL | 2 | RW | See description in BMU_INT_SRC. 0=disable 1=enable |
| EMPTY | 1 | RW | See description in BMU_INT_SRC. 0=disable 1=enable |
| ? | 0 | RW | ? |

==== BMU_ALLOC_CTRL (BMU_BASE + 0x30) ====[pfe_bmu_reg_bmu_alloc_ctrl]

Buffer allocation register.

Reading from this register will allocate one buffer from the pool and return
its address. If no free buffer is available, the value 0 is returned.

|| Symbol | Bit range | R/W | Description ||
| BUF_ADDR | 31-0 | R | Address of the buffer just allocated. |

==== BMU_FREE_CTRL (BMU_BASE + 0x34) ====[pfe_bmu_reg_bmu_free_ctrl]

Buffer free register.

Writing an address into this register will free the previously-allocated buffer
with that address.

If the address does not match any allocated buffer, an error will be reported
via the INVALID_FREE interrupt source, and the offending address will be stored
(at some point) in the BMU_FREE_ERR_ADDR register.

|| Symbol | Bit range | R/W | Description ||
| BUF_ADDR | 31-0 | W | Address of the buffer to free. |

==== BMU_FREE_ERR_ADDR (BMU_BASE + 0x38) ====[pfe_bmu_reg_bmu_free_err_addr]

Buffer free error address register (buggy, see below).

This register should contain the address which was last written into
BMU_FREE_CTRL if that address was not a valid allocated buffer.

It appears the hardware is buggy, and the correct value will not appear unless
a few other invalid free attempts are made.

|| Symbol | Bit range | R/W | Description ||
| BUF_ADDR | 31-0 | R | Address of the invalid buffer free attempt. |

==== BMU_CURR_BUF_CNT (BMU_BASE + 0x3c) ====[pfe_bmu_reg_bmu_curr_buf_cnt]

Number of buffers currently allocated.

|| Symbol | Bit range | R/W | Description ||
| BUF_CNT | 15-0 | R | Number of allocated buffers. |

==== BMU_MCAST_CNT (BMU_BASE + 0x40) ====[pfe_bmu_reg_bmu_mcast_cnt]

Purpose unknown.

|| Symbol | Bit range | R/W | Description ||
| ? | 2-0 | RW | Unknown |

==== BMU_MCAST_ALLOC_CTRL (BMU_BASE + 0x44) ====[pfe_bmu_reg_bmu_mcast_alloc_ctrl]

Purpose unknown.

|| Symbol | Bit range | R/W | Description ||
| ? | 31-0 | R | Unknown |

==== BMU_REM_BUF_CNT (BMU_BASE + 0x48) ====[pfe_bmu_reg_bmu_rem_buf_cnt]

Number of remaining free buffers in the pool.

|| Symbol | Bit range | R/W | Description ||
| BUF_CNT | 15-0 | R | Number of free buffers. |

==== BMU_LOW_WATERMARK (BMU_BASE + 0x50) ====[pfe_bmu_reg_bmu_low_watermark]

Purpose unknown.

|| Symbol | Bit range | R/W | Description ||
| ? | 15-0 | RW | Unknown. Default value: 0x0000 |

==== BMU_HIGH_WATERMARK (BMU_BASE + 0x54) ====[pfe_bmu_reg_bmu_high_watermark]

Purpose unknown.

|| Symbol | Bit range | R/W | Description ||
| ? | 15-0 | RW | Unknown. Default value: 0xffff |

==== BMU_INT_MEM_ACCESS (BMU_BASE + 0x100) ====[pfe_bmu_reg_bmu_int_mem_access]

Internal memory access register.

|| Symbol | Bit range | R/W | Description ||
| ? | 31-0 | R | Unknown. Value changes as buffers are allocated/freed. |

== Host Interface (HIF) ==[pfe_hif]

Send interrupt requests to the host to signal new packets.

=== HIF registers ===[pfe_hif_regs]

|| HIF instance | Base offset in CBUS ||
| HIF | 0x280000 |

|| Symbol | Offset | Description ||
| [HIF_VERSION #pfe_hif_reg_hif_version] | 0x000 | HIF version register (reads 0x10 on my hardware) |
| [HIF_TX_CTRL #pfe_hif_reg_hif_tx_ctrl] | 0x004 | HIF Tx control register |
| [HIF_TX_CURR_BD_ADDR #pfe_hif_reg_hif_tx_curr_bd_addr] | 0x008 | HIF Tx current buffer descriptor address |
| [HIF_TX_ALLOC #pfe_hif_reg_hif_tx_alloc] | 0x00c | HIF Tx allocation register? |
| [HIF_TX_BDP_ADDR #pfe_hif_reg_hif_tx_bdp_addr] | 0x010 | HIF Tx buffer descriptor pool address |
| [HIF_TX_STATUS #pfe_hif_reg_hif_tx_status] | 0x014 | HIF Tx status register |
| [HIF_RX_CTRL #pfe_hif_reg_hif_rx_ctrl] | 0x020 | HIF Rx status register |
| [HIF_RX_BDP_ADDR #pfe_hif_reg_hif_rx_bdp_addr] | 0x024 | HIF Rx buffer descriptor pool address |
| [HIF_RX_STATUS #pfe_hif_reg_hif_rx_status] | 0x030 | HIF Rx status |
| [HIF_INT_SRC #pfe_hif_reg_hif_int_src] | 0x034 | HIF interrupt source status register |
| [HIF_INT_ENABLE #pfe_hif_reg_hif_int_enable] | 0x038 | HIF interrupt enable register |
| [HIF_POLL_CTRL #pfe_hif_reg_hif_poll_ctrl] | 0x03c | HIF polling control register |
| [HIF_RX_CURR_BD_ADDR #pfe_hif_reg_hif_rx_curr_bd_addr] | 0x040 | HIF Rx current buffer descriptor address |
| [HIF_RX_ALLOC #pfe_hif_reg_hif_rx_alloc] | 0x044 | HIF Rx allocation register? |
| [HIF_TX_DMA_STATUS #pfe_hif_reg_hif_tx_dma_status] | 0x048 | HIF Tx DMA status register |
| [HIF_RX_DMA_STATUS #pfe_hif_reg_hif_rx_dma_status] | 0x04c | HIF Rx DMA status register |
| [HIF_INT_COAL #pfe_hif_reg_hif_int_coal] | 0x050 | HIF interrupt coalesce control register |

==== HIF_VERSION (HIF_BASE + 0x000) ====[pfe_hif_reg_hif_version]

HIF silicon revision. 0x10 on my c2k chip.

|| Symbol | Bit range | R/W | Description ||
| VERSION | ?-0 | R | HIF silicon revision |

==== HIF_TX_CTRL (HIF_BASE + 0x004) ====[pfe_hif_reg_hif_tx_ctrl]

|| Symbol | Bit range | R/W | Description ||
| BDP_CH_START_WSTB | 2 | RW | Enable buffer descriptor pool start write strobe? |
| BDP_POLL_CTRL_EN | 1 | RW | Enable polling the buffer descriptor pool? |
| DMA_EN | 0 | RW | Enable DMA operation |

==== HIF_TX_CURR_BD_ADDR (HIF_BASE + 0x008) ====[pfe_hif_reg_hif_tx_curr_bd_addr]

|| Symbol | Bit range | R/W | Description ||
| CURR_BD_ADDR | 31-0 | R | Address of the current buffer descriptor |

==== HIF_TX_ALLOC (HIF_BASE + 0x00c) ====[pfe_hif_reg_hif_tx_alloc]

Purpose unknown.

|| Symbol | Bit range | R/W | Description ||
| ? | 31-0 | W | ? |

==== HIF_TX_BDP_ADDR (HIF_BASE + 0x010) ====[pfe_hif_reg_hif_tx_bdp_addr]

Get or set the address of the Tx buffer descriptor pool.

Writing a new value will reset the Tx current buffer descriptor.

|| Symbol | Bit range | R/W | Description ||
| BDP_ADDR | 31-0 | RW | Address of the buffer descriptor pool |

==== HIF_TX_STATUS (HIF_BASE + 0x014) ====[pfe_hif_reg_hif_tx_status]

Contents unknown.

|| Symbol | Bit range | R/W | Description ||

==== HIF_RX_CTRL (HIF_BASE + 0x020) ====[pfe_hif_reg_hif_rx_ctrl]

|| Symbol | Bit range | R/W | Description ||
| BDP_CH_START_WSTB | 2 | RW | Enable buffer descriptor pool start write strobe? |
| BDP_POLL_CTRL_EN | 1 | RW | Enable polling the buffer descriptor pool? |
| DMA_EN | 0 | RW | Enable DMA operation |

==== HIF_RX_BDP_ADDR (HIF_BASE + 0x024) ====[pfe_hif_reg_hif_rx_bdp_addr]

Get or set the address of the Rx buffer descriptor pool.

Writing a new value will reset the Rx current buffer descriptor.

|| Symbol | Bit range | R/W | Description ||
| BDP_ADDR | 31-0 | RW | Address of the buffer descriptor pool |

==== HIF_RX_STATUS (HIF_BASE + 0x030) ====[pfe_hif_reg_hif_rx_status]

Contents unknown.

|| Symbol | Bit range | R/W | Description ||

==== HIF_INT_SRC (HIF_BASE + 0x034) ====[pfe_hif_reg_hif_int_src]

Interrupt source status register.

|| Symbol | Bit range | R/W | Description ||
| TXPKT_INT | 4 | R | Tx packet ??? interrupt |
| TXBD_INT | 3 | R | Tx buffer descriptor ??? interrupt |
| RXPKT_INT | 2 | R | Rx packet ??? interrupt |
| RXBD_INT | 1 | R | Rx buffer descriptor ??? interrupt |
| INT | 0 | R | Global interrupt? |

==== HIF_INT_ENABLE (HIF_BASE + 0x038) ====[pfe_hif_reg_hif_int_enable]

Interrupt source enable register.

|| Symbol | Bit range | R/W | Description ||
| TXPKT_INT | 4 | RW | Tx packet ??? interrupt enable |
| TXBD_INT | 3 | RW | Tx buffer descriptor ??? interrupt enable |
| RXPKT_INT | 2 | RW | Rx packet ??? interrupt enable |
| RXBD_INT | 1 | RW | Rx buffer descriptor ??? interrupt enable |
| INT | 0 | RW | Global interrupt enable? |

==== HIF_POLL_CTRL (HIF_BASE + 0x03c) ====[pfe_hif_reg_hif_poll_ctrl]

Polling control register

|| Symbol | Bit range | R/W | Description ||
| 31-16 | RX_POLL_CTRL_CYCLE | RW | Number of pfe_sys clock cycles between Rx buffer descriptor pool poll attempts |
| 15-0 | TX_POLL_CTRL_CYCLE | RW | Number of pfe_sys clock cycles between Tx buffer descriptor pool poll attempts |

==== HIF_RX_CURR_BD_ADDR (HIF_BASE + 0x040) ====[pfe_hif_reg_hif_rx_curr_bd_addr]

|| Symbol | Bit range | R/W | Description ||
| CURR_BD_ADDR | 31-0 | R | Address of the current buffer descriptor |

==== HIF_RX_ALLOC (HIF_BASE + 0x044) ====[pfe_hif_reg_hif_rx_alloc]

Purpose unknown.

|| Symbol | Bit range | R/W | Description ||
| ? | 31-0 | W | ? |

==== HIF_TX_DMA_STATUS (HIF_BASE + 0x048) ====[pfe_hif_reg_hif_tx_dma_status]

Contents unknown.

|| Symbol | Bit range | R/W | Description ||

==== HIF_RX_DMA_STATUS (HIF_BASE + 0x04c) ====[pfe_hif_reg_hif_rx_dma_status]

Contents unknown.

|| Symbol | Bit range | R/W | Description ||

==== HIF_INT_COAL (HIF_BASE + 0x050) ====[pfe_hif_reg_hif_int_coal]

Interrupt coalesce control register

|| Symbol | Bit range | R/W | Description ||
| 31 | INT_COAL_ENABLE | RW | Enable interrupt coalesce |
| 30-0 | TX_POLL_CTRL_CYCLE | RW | Minimum number of pfe_sys clock cycles between interrupts |




== TMU control and status registers (TMU_CSR) ==[pfe_tmu_csr]

== Class control and status registers (CLASS_CSR) ==[pfe_class_csr]

Various control and registers for all the Class PEs.

=== Class CSR registers ===[pfe_class_csr_regs]

|| Base offset in CBUS | Seen from ARM | Seen from any PE ||
| 0x00320000 | 0x9c320000 | 0xc0320000 |

Registers:

|| Offset | Symbol | Description ||
| 0x0000 | [VERSION #pfe_class_csr_reg_version] | Class PE version |
| 0x0004 | [TX_CTRL #pfe_class_csr_reg_tx_ctrl] | Class PE core control |
| 0x0010 | INQ_PKTPTR |  |
| 0x0014 | HDR_SIZE |  |
| 0x0020 | PE0_QB_DM_ADDR0 | DMEM address of 1st and 2nd buffers on QB side |
| 0x0024 | PE0_QB_DM_ADDR1 | DMEM address of 3rd and 4th buffers on QB side |
| 0x0060 | PE0_RO_DM_ADDR0 | DMEM address of 1st and 2nd buffers on RO side |
| 0x0064 | PE0_RO_DM_ADDR1 | DMEM address of 3rd and 4th buffers on RO side |
| 0x0100 | [MEM_ACCESS_ADDR #pfe_class_csr_reg_mem_access_addr] | Class PE memory access command/address register |
| 0x0104 | [MEM_ACCESS_WDATA #pfe_class_csr_reg_mem_access_wdata] | Data to write to Class PE memory |
| 0x0108 | [MEM_ACCESS_RDATA #pfe_class_csr_reg_mem_access_rdata] | Data read from Class PE memory |
| 0x0114 | TM_INQ_ADDR |  |
| 0x0118 | PE_STATUS |  |
| 0x011c | PHY1_RX_PKTS |  |
| 0x0120 | PHY1_TX_PKTS |  |
| 0x0124 | PHY1_LP_FAIL_PKTS |  |
| 0x0128 | PHY1_INTF_FAIL_PKTS |  |
| 0x012c | PHY1_INTF_MATCH_PKTS |  |
| 0x0130 | PHY1_L3_FAIL_PKTS |  |
| 0x0134 | PHY1_V4_PKTS |  |
| 0x0138 | PHY1_V6_PKTS |  |
| 0x013c | PHY1_CHKSUM_ERR_PKTS |  |
| 0x0140 | PHY1_TTL_ERR_PKTS |  |
| 0x0144 | PHY2_RX_PKTS |  |
| 0x0148 | PHY2_TX_PKTS |  |
| 0x014c | PHY2_LP_FAIL_PKTS |  |
| 0x0150 | PHY2_INTF_FAIL_PKTS |  |
| 0x0154 | PHY2_INTF_MATCH_PKTS |  |
| 0x0158 | PHY2_L3_FAIL_PKTS |  |
| 0x015c | PHY2_V4_PKTS |  |
| 0x0160 | PHY2_V6_PKTS |  |
| 0x0164 | PHY2_CHKSUM_ERR_PKTS |  |
| 0x0168 | PHY2_TTL_ERR_PKTS |  |
| 0x016c | PHY3_RX_PKTS |  |
| 0x0170 | PHY3_TX_PKTS |  |
| 0x0174 | PHY3_LP_FAIL_PKTS |  |
| 0x0178 | PHY3_INTF_FAIL_PKTS |  |
| 0x017c | PHY3_INTF_MATCH_PKTS |  |
| 0x0180 | PHY3_L3_FAIL_PKTS |  |
| 0x0184 | PHY3_V4_PKTS |  |
| 0x0188 | PHY3_V6_PKTS |  |
| 0x018c | PHY3_CHKSUM_ERR_PKTS |  |
| 0x0190 | PHY3_TTL_ERR_PKTS |  |
| 0x0194 | PHY1_ICMP_PKTS |  |
| 0x0198 | PHY1_IGMP_PKTS |  |
| 0x019c | PHY1_TCP_PKTS |  |
| 0x01a0 | PHY1_UDP_PKTS |  |
| 0x01a4 | PHY2_ICMP_PKTS |  |
| 0x01a8 | PHY2_IGMP_PKTS |  |
| 0x01ac | PHY2_TCP_PKTS |  |
| 0x01b0 | PHY2_UDP_PKTS |  |
| 0x01b4 | PHY3_ICMP_PKTS |  |
| 0x01b8 | PHY3_IGMP_PKTS |  |
| 0x01bc | PHY3_TCP_PKTS |  |
| 0x01c0 | PHY3_UDP_PKTS |  |
| 0x01c4 | PHY4_ICMP_PKTS |  |
| 0x01c8 | PHY4_IGMP_PKTS |  |
| 0x01cc | PHY4_TCP_PKTS |  |
| 0x01d0 | PHY4_UDP_PKTS |  |
| 0x01d4 | PHY4_RX_PKTS |  |
| 0x01d8 | PHY4_TX_PKTS |  |
| 0x01dc | PHY4_LP_FAIL_PKTS |  |
| 0x01e0 | PHY4_INTF_FAIL_PKTS |  |
| 0x01e4 | PHY4_INTF_MATCH_PKTS |  |
| 0x01e8 | PHY4_L3_FAIL_PKTS |  |
| 0x01ec | PHY4_V4_PKTS |  |
| 0x01f0 | PHY4_V6_PKTS |  |
| 0x01f4 | PHY4_CHKSUM_ERR_PKTS |  |
| 0x01f8 | PHY4_TTL_ERR_PKTS |  |
| 0x0200 | [PE_SYS_CLK_RATIO #pfe_class_csr_reg_pe_sys_clk_ratio] | Core clock/bus clock ratio |
| 0x0204 | AFULL_THRES |  |
| 0x0208 | GAP_BETWEEN_READS |  |
| 0x020c | MAX_BUF_CNT |  |
| 0x0210 | TSQ_FIFO_THRES |  |
| 0x0214 | TSQ_MAX_CNT |  |
| 0x0218 | IRAM_DATA_0 |  |
| 0x021c | IRAM_DATA_1 |  |
| 0x0220 | IRAM_DATA_2 |  |
| 0x0224 | IRAM_DATA_3 |  |
| 0x0228 | [BUS_ACCESS_ADDR #pfe_class_csr_reg_bus_access_addr] | Class bus access command/address register |
| 0x022c | [BUS_ACCESS_WDATA #pfe_class_csr_reg_bus_access_wdata] | Data to write to Class bus |
| 0x0230 | [BUS_ACCESS_RDATA #pfe_class_csr_reg_bus_access_rdata] | Data read from Class bus |
| 0x0234 | ROUTE_HASH_ENTRY_SIZE |  |
| 0x0238 | ROUTE_TABLE_BASE |  |
| 0x023c | [ROUTE_MULTI #pfe_class_csr_reg_route_multi] | Route table configuration |
| 0x0240 | SMEM_OFFSET |  |
| 0x0244 | LMEM_BUF_SIZE |  |
| 0x0248 | VLAN_ID |  |
| 0x024c | BMU1_BUF_FREE |  |
| 0x0250 | USE_TMU_INQ |  |
| 0x0254 | VLAN_ID1 |  |
| 0x0258 | [BUS_ACCESS_BASE #pfe_class_csr_reg_bus_access_base] | High byte of bus access address |
| 0x025c | [HIF_PARSE #pfe_class_csr_reg_hif_parse] |  |
| 0x0260 | HOST_PE0_GP | Host general purpose register for PE0 |
| 0x0264 | PE0_GP | PE general purpose register for PE0 |
| 0x0268 | HOST_PE1_GP | Host general purpose register for PE1 |
| 0x026c | PE1_GP | PE general purpose register for PE1 |
| 0x0270 | HOST_PE2_GP | Host general purpose register for PE2 |
| 0x0274 | PE2_GP | PE general purpose register for PE2 |
| 0x0278 | HOST_PE3_GP | Host general purpose register for PE3 |
| 0x027c | PE3_GP | PE general purpose register for PE3 |
| 0x0280 | HOST_PE4_GP | Host general purpose register for PE4 |
| 0x0284 | PE4_GP | PE general purpose register for PE4 |
| 0x0288 | HOST_PE5_GP | Host general purpose register for PE5 |
| 0x028c | PE5_GP | PE general purpose register for PE5 |
| 0x0290 | PE_INT_SRC |  |
| 0x0294 | PE_INT_ENABLE |  |
| 0x0298 | TPID0_TPID1 |  |
| 0x029c | TPID2 |  |
| 0x02a0 | [L4_CHKSUM_ADDR #pfe_class_csr_reg_l4_chksum_addr] |  |
| 0x02a4 | PE0_DEBUG |  |
| 0x02a8 | PE1_DEBUG |  |
| 0x02ac | PE2_DEBUG |  |
| 0x02b0 | PE3_DEBUG |  |
| 0x02b4 | PE4_DEBUG |  |
| 0x02b8 | PE5_DEBUG |  |
| 0x02bc | STATE |  |

==== VERSION (0x0000) ====[pfe_class_csr_reg_version]

Class PE block version

|| Symbol | Bit range | R/W | Description ||
| VERSION | 31-0 | R | Class PE block version. (0x20) |

==== TX_CTRL (0x0004) ====[pfe_class_csr_reg_tx_ctrl]

Class PE core state control.

|| Symbol | Bit range | R/W | Description ||
| CTRL | 1-0 | RW | Enable/reset PE cores. 0=disable 1=enable 2=software reset |

==== MEM_ACCESS_ADDR (0x0100) ====[pfe_class_csr_reg_mem_access_addr]

Class PE internal memory access command/address register.

This register allows indirect access to a PE's internal memory. Writing a
command into this register will trigger a read or write operation at the
requested address.

|| Symbol | Bit range | R/W | Description ||
| csr_pe_mem_cmd | 31 | RW | Read of write command. 0=read 1=write |
| csr_pe_mem_wren | 27-24 | RW | Bit mask indicating which data bytes will be read/written, interpreted in big endian. |
| csr_pe_mem_addr | 23-0 | RW | PE memory address to read/write. Address should be on a word boundary. |

csr_pe_mem_addr decoding:

|| Base offset | PE | Memory type | Size ||
| 0x008000 | CLASS0 | IMEM | 0x8000 |
| 0x010000 | CLASS0 | DMEM | 0x2000 |
| 0x108000 | CLASS1 | IMEM | 0x8000 |
| 0x110000 | CLASS1 | DMEM | 0x2000 |
| 0x208000 | CLASS2 | IMEM | 0x8000 |
| 0x210000 | CLASS2 | DMEM | 0x2000 |
| 0x308000 | CLASS3 | IMEM | 0x8000 |
| 0x310000 | CLASS3 | DMEM | 0x2000 |
| 0x408000 | CLASS4 | IMEM | 0x8000 |
| 0x410000 | CLASS4 | DMEM | 0x2000 |
| 0x508000 | CLASS5 | IMEM | 0x8000 |
| 0x510000 | CLASS5 | DMEM | 0x2000 |

==== MEM_ACCESS_WDATA (0x0104) ====[pfe_class_csr_reg_mem_access_wdata]

Class PE internal memory write data register. Contains the data to write when
a write request is written into
[MEM_ACCESS_ADDR #pfe_class_csr_reg_mem_access_addr]. Value is in big endian.

|| Symbol | Bit range | R/W | Description ||
| WDATA | 31-0 | RW | Word to write into internal memory |

==== MEM_ACCESS_RDATA (0x0108) ====[pfe_class_csr_reg_mem_access_rdata]

Class PE internal memory read data register. Contains the data read after
writing a read request into
[MEM_ACCESS_ADDR #pfe_class_csr_reg_mem_access_addr]. Value is in big endian.

|| Symbol | Bit range | R/W | Description ||
| RDATA | 31-0 | RW | Word read from internal memory |

==== PE_SYS_CLK_RATIO (0x0200) ====[pfe_class_csr_reg_pe_sys_clk_ratio]

Core clock/bus clock ratio.

|| Symbol | Bit range | R/W | Description ||
| RATIO | 1-0 | RW | Core clock/system bus clock ratio. 0=1:1 1=2:1 |

==== BUS_ACCESS_ADDR (0x0228) ====[pfe_class_csr_reg_bus_access_addr]

Class PE internal bus access command/address register.

This register allows indirect access to the Class bus. Writing a command into
this register will trigger a read or write operation at the requested address.

|| Symbol | Bit range | R/W | Description ||
| CMD | 31 | RW | Read of write command. 0=read 1=write |
| WIDTH | 27-24 | RW | Access width in bytes. 1=byte 2=hword 4=word. I suspect this field doesn't actually have any effect. |
| ADDR | 23-0 | RW | Class bus address where the access will be performed. Bits 31-24 are stored in [BUS_ACCESS_BASE #pfe_class_csr_reg_bus_access_base]. |

==== BUS_ACCESS_WDATA (0x022c) ====[pfe_class_csr_reg_bus_access_wdata]

Data word to write during Class bus access write request started by a write
in [BUS_ACCESS_ADDR #pfe_class_csr_reg_bus_access_addr]. Value is in big
endian.

|| Symbol | Bit range | R/W | Description ||
| WDATA | 31-0 | RW | Word to write to Class bus. Big endian. |

==== BUS_ACCESS_RDATA (0x0230) ====[pfe_class_csr_reg_bus_access_rdata]

Data word read after a Class bus access read request started by a write
in [BUS_ACCESS_ADDR #pfe_class_csr_reg_bus_access_addr]. Value is in big
endian.

|| Symbol | Bit range | R/W | Description ||
| RDATA | 31-0 | RW | Word read from Class bus. Big endian. |

==== ROUTE_MULTI (0x023c) ====[pfe_class_csr_reg_route_multi]

Route table configuration.

|| Symbol | Bit range | R/W | Description ||
| QB2BUS_LE | 15 | RW | Byte swap something? |
| HASH_TYPE | 13-12 | RW | Hash type: 0=normal 1=CRC port 2=CRC IP 3=CRC port+IP |
| CLASS_TOE | 11 | RW | ? |
| ARC_HIT_CHECK_EN | 7 | RW | ? |
| IP_ALIGNED | 6 | RW | ? |
| HW_BRIDGE_FETCH | 5 | RW | ? |
| HW_ROUTE_FETCH | 3 | RW | ? |
| PHYNO_IN_HASH | 1 | RW | Include PHY number in hash? |
| TWO_LEVEL_ROUTE | 0 | RW | ? |

==== BUS_ACCESS_BASE (0x0258) ====[pfe_class_csr_reg_bus_access_base]

|| Symbol | Bit range | R/W | Description ||
| BASE | 31-24 | RW | High byte of bus address used in indirect Class bus accesses |

==== HIF_PARSE (0x025c) ====[pfe_class_csr_reg_hif_parse]

|| Symbol | Bit range | R/W | Description ||
| HIF_PKT_OFFST | 4-1 | RW | Offset of HIF metadata in packet? |
| HIF_PKT_CLASS_EN | 0 | RW | Enable interpretation of HIF metadata? |


==== L4_CHKSUM_ADDR (0x02a0) ====[pfe_class_csr_reg_l4_chksum_addr]

|| Symbol | Bit range | R/W | Description ||
| IPV4_CHKSUM_DROP | 9 | RW | ? |
| UDP_CHKSUM_DROP | 1 | RW | ? |
| TCP_CHKSUM_DROP | 0 | RW | ? |

== Host Interface no copy (HIF nocpy) ==

== Util control and status registers (UTIL_CSR) ==

== CBUS general purpose timer (CBUS_GPT) ==


== eSi-RISC architecture ==

The PE cores are implementation of an (32 bit?) eSi-RISC core configured in
Harvard architecture.


== Traffic/Time Management/Multiplexing Unit PE (TMU) ==

eSi-RISC core. Requires firmware.

The TMU does traffic shaping and scheduling.

== Classifier PE (CLASS) ==

eSi-RISC core. Requires firmware.


== UTIL PE (UTIL or UPE) ==

eSi-RISC core. Requires firmware.

Utility PE. Does all tasks that do not fit the other PEs.

